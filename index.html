<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>互動式原子構造實驗室 (HTML5版)</title>
    <style>
        /* --- 基礎設定 --- */
        :root {
            --bg-color: #0f172a;
            --panel-bg: #1e293b;
            --text-color: #f1f5f9;
            --accent-blue: #3b82f6;
            --proton-color: #ef4444;
            --neutron-color: #94a3b8;
            --electron-color: #3b82f6;
            --border-color: #334155;
        }

        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; }
        
        body {
            margin: 0;
            font-family: 'Segoe UI', system-ui, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- 標題欄 --- */
        header {
            background-color: var(--panel-bg);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            z-index: 10;
        }
        h1 { margin: 0; font-size: 1.2rem; display: flex; align-items: center; gap: 0.5rem; }
        .btn {
            background: #334155; color: white; border: none; padding: 0.5rem 1rem;
            border-radius: 4px; cursor: pointer; font-size: 0.9rem;
        }
        .btn:active { transform: scale(0.98); }

        /* --- 主佈局 --- */
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        /* 左側資訊欄 */
        .sidebar {
            width: 300px;
            background: rgba(30, 41, 59, 0.8);
            border-right: 1px solid var(--border-color);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            overflow-y: auto;
            z-index: 5;
        }

        /* 元素卡片 */
        .element-card {
            background: #334155;
            border-radius: 12px;
            padding: 1.5rem;
            text-align: center;
            position: relative;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .atomic-number-bg {
            position: absolute; top: 0; right: 10px; font-size: 4rem; opacity: 0.1; font-weight: bold;
        }
        .symbol { font-size: 4rem; font-weight: 900; margin: 0; line-height: 1; }
        .name { font-size: 1.5rem; color: #bfdbfe; font-weight: bold; margin-top: 0.5rem; }
        .details { font-size: 0.9rem; color: #94a3b8; margin-top: 0.5rem; }
        
        .badge {
            display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; margin-top: 5px;
            background: rgba(255,255,255,0.1);
        }

        /* 統計數據 */
        .stat-row {
            display: flex; justify-content: space-between; align-items: center;
            background: #1e293b; padding: 1rem; border-radius: 8px;
            border-left: 4px solid transparent;
        }
        .stat-p { border-left-color: var(--proton-color); }
        .stat-n { border-left-color: var(--neutron-color); }
        .stat-e { border-left-color: var(--electron-color); }
        .stat-val { font-size: 1.5rem; font-weight: bold; }
        .stat-label { font-size: 0.85rem; color: #94a3b8; }

        /* 右側原子區 */
        .main-canvas {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none; /* 防止手機滑動 */
        }

        svg {
            width: 100%;
            height: 100%;
            max-width: 800px;
            max-height: 800px;
        }

        /* 粒子動畫 */
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .orbit-group { transform-origin: 200px 200px; }

        /* 底部控制區 */
        .controls {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            border-radius: 50px;
            display: flex;
            gap: 2rem;
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            z-index: 20;
        }

        .source-item {
            display: flex; flex-direction: column; align-items: center; gap: 0.5rem; cursor: grab;
        }
        .source-item:active { cursor: grabbing; }
        .ball {
            width: 50px; height: 50px; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 1.1rem; color: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.2);
            transition: transform 0.1s;
        }
        .ball:active { transform: scale(0.9); }
        .ball-p { background: var(--proton-color); }
        .ball-n { background: var(--neutron-color); }
        .ball-e { background: var(--electron-color); }
        .label { font-size: 0.8rem; font-weight: bold; color: #cbd5e1; }

        /* 拖曳中的 Ghost */
        .ghost {
            pointer-events: none;
            opacity: 0.8;
            z-index: 100;
        }

        /* 響應式 */
        @media (max-width: 768px) {
            .container { flex-direction: column; }
            .sidebar { 
                width: 100%; height: auto; max-height: 25vh; 
                flex-direction: row; padding: 1rem; gap: 1rem;
            }
            .element-card { flex: 1; padding: 0.5rem; display: flex; align-items: center; justify-content: space-around; text-align: left; }
            .stats-container { display: none; } /* 手機版隱藏詳細列表以節省空間 */
            .controls { bottom: 1rem; padding: 0.5rem 1.5rem; gap: 1.5rem; }
            .ball { width: 40px; height: 40px; font-size: 0.9rem; }
            .atomic-number-bg { display: none; }
        }
    </style>
</head>
<body>

<header>
    <h1>
        <!-- 簡單的原子圖標 -->
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="3"/>
            <ellipse cx="12" cy="12" rx="10" ry="4" transform="rotate(0)"/>
            <ellipse cx="12" cy="12" rx="10" ry="4" transform="rotate(60)"/>
            <ellipse cx="12" cy="12" rx="10" ry="4" transform="rotate(120)"/>
        </svg>
        原子構造實驗室
    </h1>
    <button class="btn" onclick="app.reset()">重置</button>
</header>

<div class="container">
    <!-- 左側資訊面板 -->
    <aside class="sidebar">
        <div class="element-card" id="elementCard">
            <div class="atomic-number-bg" id="bgNum">1</div>
            <div>
                <div class="symbol" id="elSymbol">H</div>
                <div class="name" id="elName">氫</div>
                <div class="details">原子序: <span id="elAtomicNum">1</span></div>
                <div class="details">質量數: <span id="elMass">1</span></div>
                <div id="badgesArea"></div>
            </div>
            <!-- 手機版顯示電荷 -->
            <div class="mobile-charge" style="font-size: 1.5rem; font-weight: bold; color: #cbd5e1;">
                <span id="elCharge">0</span>
            </div>
        </div>

        <div class="stats-container" style="display: flex; flex-direction: column; gap: 1rem; width: 100%;">
            <div class="stat-row stat-p">
                <div>
                    <div style="color: #cbd5e1;">質子 (Protons)</div>
                    <div style="font-size: 0.7rem; color: #64748b;">決定元素種類</div>
                </div>
                <div class="stat-val" id="countP">1</div>
            </div>
            <div class="stat-row stat-n">
                <div>
                    <div style="color: #cbd5e1;">中子 (Neutrons)</div>
                    <div style="font-size: 0.7rem; color: #64748b;">決定同位素</div>
                </div>
                <div class="stat-val" id="countN">0</div>
            </div>
            <div class="stat-row stat-e">
                <div>
                    <div style="color: #cbd5e1;">電子 (Electrons)</div>
                    <div style="font-size: 0.7rem; color: #64748b;">決定電荷</div>
                </div>
                <div class="stat-val" id="countE">1</div>
            </div>
        </div>
        
        <div style="margin-top: auto; text-align: center; font-size: 0.8rem; color: #64748b; padding-top:1rem;">
            提示：拖曳下方粒子放入原子。<br>將原子內的粒子往外拖即可丟棄。
        </div>
    </aside>

    <!-- 右側畫布 -->
    <main class="main-canvas" id="canvasArea">
        <svg id="atomSvg" viewBox="0 0 400 400" preserveAspectRatio="xMidYMid meet">
            <defs>
                <radialGradient id="nucleusGlow">
                    <stop offset="0%" stop-color="rgba(255,255,255,0.3)"/>
                    <stop offset="100%" stop-color="rgba(255,255,255,0)"/>
                </radialGradient>
            </defs>
            
            <!-- 背景網格 -->
            <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
                <path d="M 40 0 L 0 0 0 40" fill="none" stroke="rgba(255,255,255,0.05)" stroke-width="1"/>
            </pattern>
            <rect width="400" height="400" fill="url(#grid)" />

            <!-- 軌道層 (靜態) -->
            <g id="orbitRings" opacity="0.3" stroke="white" stroke-width="1" stroke-dasharray="4 4" fill="none">
                <!-- JS 動態生成 -->
            </g>

            <!-- 原子核光暈 -->
            <circle cx="200" cy="200" r="40" fill="url(#nucleusGlow)" id="nucleusAura"/>

            <!-- 粒子層 -->
            <g id="nucleusGroup" transform="translate(200, 200)"></g>
            <g id="electronGroup" transform="translate(200, 200)"></g>

            <!-- 拖曳中的鬼影 (最上層) -->
            <circle id="dragGhost" cx="-100" cy="-100" r="8" fill="red" opacity="0" pointer-events="none" stroke="white" stroke-width="2"/>
        </svg>

        <!-- 粒子來源 (下方) -->
        <div class="controls">
            <div class="source-item" data-type="proton">
                <div class="ball ball-p">P<sup>+</sup></div>
                <span class="label">質子</span>
            </div>
            <div class="source-item" data-type="neutron">
                <div class="ball ball-n">N<sup>0</sup></div>
                <span class="label">中子</span>
            </div>
            <div class="source-item" data-type="electron">
                <div class="ball ball-e">e<sup>-</sup></div>
                <span class="label">電子</span>
            </div>
        </div>
    </main>
</div>

<script>
/**
 * 互動式原子構造實驗室 (HTML5 Vanilla JS)
 */

// 元素資料
const ELEMENTS = {
  0: { symbol: '?', name: '無' },
  1: { symbol: 'H', name: '氫' },
  2: { symbol: 'He', name: '氦' },
  3: { symbol: 'Li', name: '鋰' },
  4: { symbol: 'Be', name: '鈹' },
  5: { symbol: 'B', name: '硼' },
  6: { symbol: 'C', name: '碳' },
  7: { symbol: 'N', name: '氮' },
  8: { symbol: 'O', name: '氧' },
  9: { symbol: 'F', name: '氟' },
  10: { symbol: 'Ne', name: '氖' },
  11: { symbol: 'Na', name: '鈉' },
  12: { symbol: 'Mg', name: '鎂' },
  13: { symbol: 'Al', name: '鋁' },
  14: { symbol: 'Si', name: '矽' },
  15: { symbol: 'P', name: '磷' },
  16: { symbol: 'S', name: '硫' },
  17: { symbol: 'Cl', name: '氯' },
  18: { symbol: 'Ar', name: '氬' },
  19: { symbol: 'K', name: '鉀' },
  20: { symbol: 'Ca', name: '鈣' }
};

const CONSTANTS = {
    CENTER: 200,
    NUCLEUS_BASE_R: 40,
    PARTICLE_R: 6,
    SHELL_BASE_R: 70,
    SHELL_GAP: 40,
    ATOM_ZONE: 180 // 判斷放入或丟出的半徑範圍
};

class AtomApp {
    constructor() {
        this.state = {
            protons: [],
            neutrons: [],
            electrons: []
        };
        
        this.dragState = {
            active: false,
            type: null, // 'proton', 'neutron', 'electron'
            source: null, // 'bin', 'atom'
            id: null, // particle ID if from atom
            offsetX: 0,
            offsetY: 0
        };

        this.svg = document.getElementById('atomSvg');
        this.ghost = document.getElementById('dragGhost');
        this.orbitGroup = document.getElementById('orbitRings');
        
        this.init();
    }

    init() {
        this.reset();
        this.setupEvents();
        this.animate();
    }

    reset() {
        // 預設: 氫原子
        this.state.protons = [{ id: Date.now(), x: 0, y: 0 }];
        this.state.neutrons = [];
        this.state.electrons = [{ id: Date.now()+1, angle: Math.random() * 360 }];
        this.render();
    }

    // --- 邏輯操作 ---

    addParticle(type) {
        if (type === 'proton' && this.state.protons.length >= 20) {
            alert('本模擬器最高支援至原子序 20 (鈣)');
            return;
        }

        const id = Date.now() + Math.random();
        
        if (type === 'proton' || type === 'neutron') {
            // 在核內隨機分佈
            const r = Math.sqrt(Math.random()) * (CONSTANTS.NUCLEUS_BASE_R * 0.8);
            const theta = Math.random() * 2 * Math.PI;
            const p = { id, x: r * Math.cos(theta), y: r * Math.sin(theta) };
            
            if (type === 'proton') this.state.protons.push(p);
            else this.state.neutrons.push(p);
        } else {
            // 電子
            this.state.electrons.push({ id, angle: Math.random() * 360 });
        }
        this.render();
    }

    removeParticle(type, id) {
        if (type === 'proton') {
            this.state.protons = this.state.protons.filter(p => p.id !== id);
        } else if (type === 'neutron') {
            this.state.neutrons = this.state.neutrons.filter(p => p.id !== id);
        } else if (type === 'electron') {
            this.state.electrons = this.state.electrons.filter(p => p.id !== id);
        }
        this.render();
    }

    // --- 渲染 (View) ---

    render() {
        this.updateStats();
        this.drawNucleus();
        this.drawElectrons();
    }

    updateStats() {
        const p = this.state.protons.length;
        const n = this.state.neutrons.length;
        const e = this.state.electrons.length;
        const mass = p + n;
        const charge = p - e;
        const element = ELEMENTS[p] || { symbol: '???', name: '未知' };

        // 更新左側文字
        document.getElementById('elSymbol').textContent = element.symbol;
        document.getElementById('elName').textContent = element.name;
        document.getElementById('elAtomicNum').textContent = p;
        document.getElementById('elMass').textContent = mass;
        document.getElementById('bgNum').textContent = p;
        
        document.getElementById('countP').textContent = p;
        document.getElementById('countN').textContent = n;
        document.getElementById('countE').textContent = e;

        // 電荷顏色與顯示
        const chargeEl = document.getElementById('elCharge');
        let chargeStr = charge === 0 ? '0' : (Math.abs(charge) + (charge > 0 ? '+' : '-'));
        chargeEl.textContent = chargeStr;
        chargeEl.className = charge > 0 ? 'text-red-400' : (charge < 0 ? 'text-blue-400' : 'text-gray-200');
        chargeEl.style.color = charge > 0 ? '#f87171' : (charge < 0 ? '#60a5fa' : '#e2e8f0');

        // 標籤 (離子/穩定性)
        const badgesArea = document.getElementById('badgesArea');
        badgesArea.innerHTML = '';
        
        // 離子標籤
        if (p > 0) {
            if (charge !== 0) {
                const span = document.createElement('span');
                span.className = 'badge';
                span.style.color = '#fde047'; // yellow
                span.textContent = '離子';
                badgesArea.appendChild(span);
            } else {
                const span = document.createElement('span');
                span.className = 'badge';
                span.style.color = '#86efac'; // green
                span.textContent = '中性原子';
                badgesArea.appendChild(span);
            }
        }
        
        // 簡單的不穩定判定 (中子數與質子數差異過大)
        if (p > 0 && Math.abs(p - n) > p * 0.6 + 1) {
            const span = document.createElement('span');
            span.className = 'badge';
            span.style.color = '#fca5a5'; // red
            span.textContent = '不穩定';
            badgesArea.appendChild(span);
        }
    }

    drawNucleus() {
        const group = document.getElementById('nucleusGroup');
        group.innerHTML = ''; // Clear

        // 為了視覺效果，混合繪製質子與中子
        // 這裡不需要複雜的物理碰撞，只要畫出來即可
        // 注意：如果正在拖曳某個粒子，則不在這裡繪製它 (它會由 Ghost 顯示)
        
        const drawItem = (item, type, color) => {
            if (this.dragState.active && this.dragState.source === 'atom' && this.dragState.id === item.id) return;

            const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            c.setAttribute("cx", item.x);
            c.setAttribute("cy", item.y);
            c.setAttribute("r", CONSTANTS.PARTICLE_R);
            c.setAttribute("fill", color);
            c.setAttribute("stroke", "rgba(0,0,0,0.3)");
            c.setAttribute("stroke-width", "1");
            c.style.cursor = "grab";
            
            // 綁定拖曳事件 (從原子內拖出)
            c.addEventListener('pointerdown', (e) => this.handleDragStartFromAtom(e, type, item.id));
            
            group.appendChild(c);
        };

        this.state.neutrons.forEach(n => drawItem(n, 'neutron', '#94a3b8'));
        this.state.protons.forEach(p => drawItem(p, 'proton', '#ef4444'));

        // 更新原子核大小光暈
        const nucleusR = CONSTANTS.NUCLEUS_BASE_R + (this.state.protons.length * 0.5);
        document.getElementById('nucleusAura').setAttribute('r', nucleusR);
    }

    drawElectrons() {
        const group = document.getElementById('electronGroup');
        const orbitContainer = document.getElementById('orbitRings');
        group.innerHTML = '';
        orbitContainer.innerHTML = '';

        // 分配電子殼層 (2, 8, 8, 18...)
        const shells = [];
        let remaining = this.state.electrons.length;
        let eIndex = 0;
        
        const capacities = [2, 8, 8, 18]; // 簡化版

        for (let i = 0; i < capacities.length; i++) {
            if (remaining <= 0) break;
            const count = Math.min(remaining, capacities[i]);
            const layerElectrons = [];
            for(let j=0; j<count; j++) {
                layerElectrons.push(this.state.electrons[eIndex++]);
            }
            shells.push(layerElectrons);
            remaining -= count;
        }

        // 繪製軌道和電子
        shells.forEach((shell, shellIndex) => {
            const r = CONSTANTS.SHELL_BASE_R + (shellIndex * CONSTANTS.SHELL_GAP);
            
            // 繪製軌道圈
            const ring = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            ring.setAttribute("cx", 200);
            ring.setAttribute("cy", 200);
            ring.setAttribute("r", r);
            orbitContainer.appendChild(ring);

            // 建立旋轉群組 (CSS Animation)
            const rotateG = document.createElementNS("http://www.w3.org/2000/svg", "g");
            rotateG.classList.add("orbit-group");
            // 每個軌道旋轉速度不同
            rotateG.style.animation = `spin ${10 + shellIndex * 5}s linear infinite`;
            
            // 繪製電子
            const angleStep = 360 / shell.length;
            shell.forEach((e, i) => {
                if (this.dragState.active && this.dragState.source === 'atom' && this.dragState.id === e.id) return;

                const angleDeg = (i * angleStep); 
                const rad = (angleDeg * Math.PI) / 180;
                const ex = 200 + r * Math.cos(rad); // 相對中心 200,200
                const ey = 200 + r * Math.sin(rad);

                // 因為外層 g 已經 translate(200,200)，所以這裡的座標要減去 200
                // 但為了配合 CSS 旋轉 (transform-origin 200 200)，我們最好讓 rotateG 位於 0,0 視窗座標，然後內容物在絕對位置?
                // 修正： electronGroup 已有 translate(200,200)。
                // 為了讓旋轉簡單，我們在 group 內部繪製相對座標
                
                const relX = r * Math.cos(rad);
                const relY = r * Math.sin(rad);

                const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                c.setAttribute("cx", relX);
                c.setAttribute("cy", relY);
                c.setAttribute("r", 5);
                c.setAttribute("fill", "#3b82f6");
                c.setAttribute("stroke", "#1e3a8a");
                c.style.cursor = "grab";

                // 因為旋轉層會轉，PointerEvent 的座標計算會變得很複雜
                // 為了簡化 "丟出" 操作，我們在電子上綁定事件時，要特別小心
                // 簡單作法：禁止旋轉層影響點擊？ 不，需要點擊。
                // 當點擊發生時，我們計算當前螢幕座標，然後開始拖曳。
                
                c.addEventListener('pointerdown', (ev) => {
                    // 必須阻止旋轉層的事件冒泡或獲取當前絕對位置
                    // 使用 getBoundingClientRect 獲取當前視覺位置
                    const rect = c.getBoundingClientRect();
                    // 轉換回 SVG 座標
                    const pt = this.svg.createSVGPoint();
                    pt.x = rect.left + rect.width/2;
                    pt.y = rect.top + rect.height/2;
                    const svgP = pt.matrixTransform(this.svg.getScreenCTM().inverse());
                    
                    // 這裡的 e.id 是重要的
                    this.handleDragStartFromAtom(ev, 'electron', e.id, svgP.x, svgP.y);
                });

                rotateG.appendChild(c);
            });
            group.appendChild(rotateG);
        });
    }

    // --- 拖曳事件處理 (Drag & Drop) ---

    setupEvents() {
        // 綁定下方來源按鈕
        document.querySelectorAll('.source-item').forEach(item => {
            item.addEventListener('pointerdown', (e) => {
                const type = item.getAttribute('data-type');
                this.handleDragStartFromBin(e, type);
            });
        });

        // 全局移動與放開
        window.addEventListener('pointermove', (e) => this.handleDragMove(e));
        window.addEventListener('pointerup', (e) => this.handleDragEnd(e));
        window.addEventListener('pointercancel', (e) => this.handleDragEnd(e));
    }

    getSVGPos(e) {
        const pt = this.svg.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        return pt.matrixTransform(this.svg.getScreenCTM().inverse());
    }

    handleDragStartFromBin(e, type) {
        e.preventDefault();
        const pos = this.getSVGPos(e);
        this.startDrag(type, 'bin', null, pos);
    }

    handleDragStartFromAtom(e, type, id, startX, startY) {
        e.stopPropagation(); // 避免觸發其他
        e.preventDefault();
        // 如果有傳入起始座標(給電子用)，使用之，否則計算滑鼠位置
        const pos = (startX !== undefined) ? {x: startX, y: startY} : this.getSVGPos(e);
        this.startDrag(type, 'atom', id, pos);
        
        // 觸發重繪以隱藏原始粒子
        this.render();
    }

    startDrag(type, source, id, pos) {
        this.dragState = {
            active: true,
            type,
            source,
            id,
            x: pos.x,
            y: pos.y
        };

        // 設定 Ghost 樣式
        let color = '#3b82f6';
        if (type === 'proton') color = '#ef4444';
        if (type === 'neutron') color = '#94a3b8';

        this.ghost.setAttribute('fill', color);
        this.ghost.setAttribute('cx', pos.x);
        this.ghost.setAttribute('cy', pos.y);
        this.ghost.setAttribute('opacity', 0.8);
        this.ghost.setAttribute('r', source === 'atom' ? CONSTANTS.PARTICLE_R * 1.5 : 8);
    }

    handleDragMove(e) {
        if (!this.dragState.active) return;
        
        const pos = this.getSVGPos(e);
        this.dragState.x = pos.x;
        this.dragState.y = pos.y;

        // 更新 Ghost 位置
        this.ghost.setAttribute('cx', pos.x);
        this.ghost.setAttribute('cy', pos.y);

        // 視覺提示：計算距離
        const dist = Math.sqrt((pos.x - CONSTANTS.CENTER)**2 + (pos.y - CONSTANTS.CENTER)**2);
        const inZone = dist < CONSTANTS.ATOM_ZONE;

        if (this.dragState.source === 'bin' && inZone) {
            this.ghost.setAttribute('stroke', '#4ade80'); // Green stroke
            this.ghost.setAttribute('stroke-width', '3');
        } else if (this.dragState.source === 'atom' && !inZone) {
            this.ghost.setAttribute('stroke', '#f87171'); // Red stroke for remove
            this.ghost.setAttribute('stroke-width', '3');
        } else {
            this.ghost.setAttribute('stroke', 'white');
            this.ghost.setAttribute('stroke-width', '2');
        }
    }

    handleDragEnd(e) {
        if (!this.dragState.active) return;

        const { x, y, type, source, id } = this.dragState;
        const dist = Math.sqrt((x - CONSTANTS.CENTER)**2 + (y - CONSTANTS.CENTER)**2);
        const inZone = dist < CONSTANTS.ATOM_ZONE;

        if (source === 'bin') {
            // 從籃子加入
            if (inZone) {
                this.addParticle(type);
            }
        } else if (source === 'atom') {
            // 從原子移除
            if (!inZone) {
                this.removeParticle(type, id);
            } else {
                // 放回原子內 (什麼都不做，重繪會顯示回來)
                this.render();
            }
        }

        // 重置拖曳狀態
        this.dragState.active = false;
        this.ghost.setAttribute('opacity', 0);
        this.ghost.setAttribute('cx', -100);
    }

    animate() {
        // SVG 動畫主要靠 CSS，但如果需要更複雜的物理可以在這裡加 requestAnimationFrame
        // 目前不需要
    }
}

// 啟動應用
const app = new AtomApp();

</script>
</body>
</html>